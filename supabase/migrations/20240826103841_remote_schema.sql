create table "public"."notify" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "name" text not null,
    "image" text not null,
    "user_id" bigint not null,
    "season" text not null
);


alter table "public"."notify" enable row level security;

create table "public"."notify_chap" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "chap_id" text not null,
    "name" text not null,
    "time" timestamp with time zone not null,
    "notify_id" bigint not null
);


alter table "public"."notify_chap" enable row level security;

alter table "public"."history" add column "v_chap" bigint;

CREATE INDEX history_user_id_season_idx ON public.history USING btree (user_id, season);

CREATE INDEX history_v_chap_idx ON public.history USING btree (v_chap);

CREATE UNIQUE INDEX notifications_pkey ON public.notify USING btree (id);

CREATE INDEX notify_chap_chap_id_idx ON public.notify_chap USING btree (chap_id);

CREATE INDEX notify_chap_notify_id_idx ON public.notify_chap USING btree (notify_id);

CREATE UNIQUE INDEX notify_chap_pkey ON public.notify_chap USING btree (id);

CREATE INDEX notify_user_id_season_idx ON public.notify USING btree (user_id, season);

alter table "public"."notify" add constraint "notifications_pkey" PRIMARY KEY using index "notifications_pkey";

alter table "public"."notify_chap" add constraint "notify_chap_pkey" PRIMARY KEY using index "notify_chap_pkey";

alter table "public"."history" add constraint "history_v_chap_fkey" FOREIGN KEY (v_chap) REFERENCES chaps(id) not valid;

alter table "public"."history" validate constraint "history_v_chap_fkey";

alter table "public"."notify" add constraint "notifications_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(id) not valid;

alter table "public"."notify" validate constraint "notifications_user_id_fkey";

alter table "public"."notify_chap" add constraint "notify_chap_notify_id_fkey" FOREIGN KEY (notify_id) REFERENCES notify(id) not valid;

alter table "public"."notify_chap" validate constraint "notify_chap_notify_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.delete_notify(user_uid text, p_season text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    i_user_id integer;
    i_notify int8;
BEGIN
    -- Check if user exists and get user id
    SELECT u.id INTO i_user_id
    FROM users u
    WHERE u.uuid = p_user_uid
    LIMIT 1;

    IF i_user_id IS NULL THEN
        RAISE EXCEPTION 'User does not exist';
    END IF;

    select id into i_notify
    from notify
    where season = p_season
    and user_id = i_user_id
    limit 1;

    if i_notify is null then
      raise exception 'Season does not exist';
    end if;

    delete from notify_chap
    where notify_id = i_notify;

    delete from notify where id = i_notify;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.delete_notify(user_uid text, p_season text, p_chapid text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    i_user_id integer;
    i_notify int8;
BEGIN
    -- Check if user exists and get user id
    SELECT u.id INTO i_user_id
    FROM users u
    WHERE u.uuid = p_user_uid
    LIMIT 1;

    IF i_user_id IS NULL THEN
        RAISE EXCEPTION 'User does not exist';
    END IF;

    select id into i_notify
    from notify
    where season = p_season
    and user_id = i_user_id
    limit 1;

    if i_notify is null then
      raise exception 'Season does not exist';
    end if;

    delete from notify_chap
    where notify_id = i_notify
    and chap_id = p_chapId;

    if not exists (
      select 1 from notify_chap where notify_id = i_notify limit 1
    ) then
      delete from notify where id = i_notify;
    end if;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_count_notify(p_user_uid text)
 RETURNS TABLE(notify_count integer, notify_chap_count integer)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    i_user_id integer;
    notify_count integer;
    notify_chap_count integer;
BEGIN
    -- Check if user exists and get user id
    SELECT u.id INTO i_user_id
    FROM users u
    WHERE u.uuid = p_user_uid
    LIMIT 1;

    IF i_user_id IS NULL THEN
        RAISE EXCEPTION 'User does not exist';
    END IF;

    -- Count number of notifications
    SELECT COUNT(*) INTO notify_count 
    FROM notify 
    WHERE user_id = i_user_id;

    -- Count number of related notify_chap records
    SELECT COUNT(*) INTO notify_chap_count
    FROM notify n
    LEFT JOIN notify_chap nc ON nc.notify_id = n.id
    WHERE n.user_id = i_user_id;

    RETURN QUERY SELECT notify_count, notify_chap_count;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.query_notify(p_user_uid text, p_page integer, p_page_size integer)
 RETURNS TABLE(created_at timestamp with time zone, name text, image text, season text, latest_chap_time timestamp with time zone, episodes jsonb)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    i_user_id integer;
BEGIN
    -- Check if user exists and get user id
    SELECT u.id INTO i_user_id
    FROM users u
    WHERE u.uuid = p_user_uid
    LIMIT 1;

    IF i_user_id IS NULL THEN
        RAISE EXCEPTION 'User does not exist';
    END IF;

    -- Set the query limit to the provided limit or maximum of 50
    p_page_size := LEAST(p_page_size, 50);
    
    RETURN QUERY
    SELECT
        n.created_at,
        n.name,
        n.image,
        n.season,
        max(nc.time) AS latest_chap_time,
        jsonb_agg(jsonb_build_object(
            'id', nc.id,
            'created_at', nc.created_at,
            'chap_id', nc.chap_id,
            'name', nc.name,
            'time', nc.time
        ) ORDER BY nc.time DESC) AS episodes
    FROM
        public.notify n
    LEFT JOIN
        public.notify_chap nc ON nc.notify_id = n.id
    WHERE
        n.user_id = i_user_id
    GROUP BY
        n.id, n.created_at, n.name, n.image, n.user_id, n.season
    ORDER BY
        latest_chap_time DESC
    LIMIT
        p_page_size
    OFFSET
        (p_page - 1) * p_page_size;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.upsert_notify(p_image text, p_name text, p_chap text, p_time timestamp with time zone, p_season text, p_chapid text, user_uid text)
 RETURNS TABLE(notify_count integer, notify_chap_count integer)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    p_user_id int8;
    i_notify_id int8;
BEGIN
    -- Check if user exists and get user id
    SELECT id INTO p_user_id
    FROM users
    WHERE uuid = user_uid
    LIMIT 1;

    IF p_user_id IS NULL THEN
        RAISE EXCEPTION 'User does not exist';
    END IF;

    select id into i_notify_id
    from notify
    where season = p_season
    and user_id = p_user_id
    limit 1;

    if i_notify_id is null then
      insert into notify(name, image, user_id, season)
      values (p_name, p_image, p_user_id, p_season)
      returning id into i_notify_id;
    end if;

    -- search notify this episode exists
    if not exists(
        select 1
        from notify_chap
        where notify_id = i_notify_id
        and chap_id = p_chapId
        limit 1
    ) then
      insert into notify_chap(chap_id, name, time, notify_id)
      values (p_chapId, p_chap, p_time, i_notify_id);
    end if;

    return query select * from get_count_notify(user_uid);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.upsert_notifys(p_data jsonb, user_uid text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    p_user_id int8;
    i_notify_id int8;
    t_item jsonb;
    p_image text;
    p_name text;
    p_chap text;
    p_time timestamptz;
    p_season text;
    p_chapId text;
BEGIN
    -- Check if user exists and get user id
    SELECT id INTO p_user_id
    FROM users
    WHERE uuid = user_uid
    LIMIT 1;

    IF p_user_id IS NULL THEN
        RAISE EXCEPTION 'User does not exist';
    END IF;

    -- Loop through each item in the JSON array
    FOR t_item IN SELECT * FROM jsonb_array_elements(p_data)
    LOOP
        -- Extract fields from the JSON object
        p_image := t_item->>'image';
        p_name := t_item->>'name';
        p_chap := t_item->>'chap';
        p_time := (t_item->>'time')::timestamptz;
        p_season := t_item->>'season';
        p_chapId := t_item->>'chapId';

        -- Check if notify already exists
        SELECT id INTO i_notify_id
        FROM notify
        WHERE season = p_season
        AND user_id = p_user_id
        LIMIT 1;

        -- Insert notify if it doesn't exist
        IF i_notify_id IS NULL THEN
            INSERT INTO notify(name, image, user_id, season)
            VALUES (p_name, p_image, p_user_id, p_season)
            RETURNING id INTO i_notify_id;
        END IF;

        -- Insert notify_chap if it doesn't exist
        IF NOT EXISTS (
            SELECT 1
            FROM notify_chap
            WHERE notify_id = i_notify_id
            AND chap_id = p_chapId
            LIMIT 1
        ) THEN
            INSERT INTO notify_chap(chap_id, name, time, notify_id)
            VALUES (p_chapId, p_chap, p_time, i_notify_id);
        END IF;
    END LOOP;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.query_history(user_uid text, page integer, size integer)
 RETURNS TABLE(created_at timestamp with time zone, season text, name text, poster text, season_name text, watch_updated_at timestamp with time zone, watch_name text, watch_id text, watch_cur double precision, watch_dur double precision)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    query_limit integer;
    i_user_id integer;
BEGIN
    -- Check if user exists and get user id
    SELECT u.id INTO i_user_id
    FROM users u
    WHERE u.uuid = user_uid
    LIMIT 1;

    IF i_user_id IS NULL THEN
        RAISE EXCEPTION 'User does not exist';
    END IF;

    -- Set the query limit to the provided limit or maximum of 50
    query_limit := LEAST(size, 50);
    
    RETURN QUERY
    SELECT
      h.created_at, h.season, h.name, h.poster, h.season_name,
      c.updated_at as watch_updated_at, c.name as watch_name,
      c.chap_id as watch_id, c.cur as watch_cur, c.dur as watch_dur
    FROM public.history h
    
    LEFT JOIN LATERAL (
        SELECT c.*
        FROM public.chaps c
        WHERE 
            c.id = h.v_chap
            OR c.history_id = h.for_to
            OR c.history_id = h.id
            OR ( 
                c.history_id IN (
                    SELECT h_alt.id
                    FROM public.history h_alt
                    WHERE h_alt.user_id = h.user_id AND h_alt.season = h.season
                )
            )
        ORDER BY
            c.updated_at DESC,
            CASE 
                WHEN c.id = h.v_chap THEN 1
                WHEN c.history_id = h.for_to THEN 2
                WHEN c.history_id = h.id THEN 3
                ELSE 4
            END
        LIMIT 1
    ) c ON TRUE

    where h.user_id = i_user_id
    ORDER BY h.created_at DESC
    LIMIT query_limit OFFSET (page - 1) * query_limit;

-- SELECT
--     h.*,
--     c.*
-- FROM
--     public.history h
-- LEFT JOIN LATERAL (
--     SELECT c.*
--     FROM public.chaps c
--     WHERE
--         c.history_id = h.id
--         OR (
--             c.history_id IN (
--                 SELECT h_alt.id
--                 FROM public.history h_alt
--                 WHERE h_alt.user_id = 854 AND h_alt.season = h.season
--             )
--         )
--     ORDER BY
--         CASE WHEN c.history_id = h.id THEN 1 ELSE 2 END
--     LIMIT 1
-- ) c ON TRUE
-- WHERE
--     h.user_id = 854
-- ORDER BY
--     h.created_at DESC
-- LIMIT 1;


-- WITH chaps_match AS (
--     SELECT *
--     FROM public.chaps
--     WHERE history_id IN (
--         SELECT h_alt.id
--         FROM public.history h_alt
--         WHERE h_alt.user_id = 854
--         AND h_alt.season = (SELECT season FROM public.history WHERE id = h.id)
--     )
--     ORDER BY history_id = h.id DESC
--     LIMIT 1
-- )
-- SELECT
--     h.*,
--     c.*
-- FROM public.history h
-- LEFT JOIN chaps_match c ON c.history_id = h.id
-- WHERE h.user_id = 854
-- ORDER BY h.created_at DESC
-- LIMIT 1;

END;
$function$
;

CREATE OR REPLACE FUNCTION public.set_single_progress(p_name text, p_poster text, season_id text, p_season_name text, user_uid text, e_cur double precision, e_dur double precision, e_name text, e_chap text, gmt text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    latest_history record;
    i_user_id int8;
    id_history_rax int8;
    id_chap int8;
    new_id int8;
BEGIN
    -- Check if user exists and get user id
    SELECT u.id INTO i_user_id
    FROM users u
    WHERE u.uuid = user_uid
    LIMIT 1;

    IF i_user_id IS NULL THEN
        RAISE EXCEPTION 'User does not exist';
    END IF;

    IF e_dur <= 0 THEN
        RAISE EXCEPTION 'Duration must be greater than 0';
    END IF;

    IF e_dur < e_cur THEN
        RAISE EXCEPTION 'Duration must be current';
    END IF;

    -- Get the latest history record for the user and season
    SELECT h.* INTO latest_history
    FROM history h
    JOIN users u ON h.user_id = u.id
    WHERE u.uuid = user_uid AND h.season = season_id
    ORDER BY h.created_at DESC
    LIMIT 1;

    SELECT h_alt.id into id_history_rax
    FROM public.history h_alt
    WHERE h_alt.user_id = i_user_id
    AND h_alt.season = season_id
    AND EXISTS (
      SELECT 1 FROM public.chaps c WHERE c.history_id = h_alt.id limit 1
    )
    ORDER by h_alt.created_at ASC
    LIMIT 1;

    -- Insert new history if it does not exist or is not the latest for today
    IF latest_history IS NULL OR (latest_history.created_at::timestamptz at TIME ZONE gmt)::DATE <> (NOW()::timestamptz at TIME ZONE gmt)::DATE THEN
        INSERT INTO history (created_at, user_id, season, name, poster, season_name, for_to, v_chap)
        VALUES (NOW(), i_user_id, season_id, p_name, p_poster, p_season_name, id_history_rax, NULL)
        RETURNING id INTO new_id;

        IF id_history_rax is NULL then
          id_history_rax := new_id;
        end if;
        
        latest_history := NULL;
    END IF;

    IF id_history_rax IS NULL THEN
        RAISE EXCEPTION 'Failed to retrieve or create history record';
    END IF;

    -- Check if the chapter already exists for the history record
    SELECT c.id INTO id_chap
    FROM chaps c
    JOIN history h ON c.history_id = h.id
    JOIN users u ON h.user_id = u.id
    WHERE u.uuid = user_uid AND h.season = season_id AND c.chap_id = e_chap
    LIMIT 1;

    -- Insert or update the chapter
    IF id_chap IS NULL THEN
        DELETE FROM chaps
        USING history h
        JOIN users u ON h.user_id = u.id
        WHERE chaps.history_id = h.id AND h.season = season_id AND chaps.chap_id = e_chap AND u.uuid = user_uid;
        
        INSERT INTO chaps (created_at, history_id, cur, dur, name, updated_at, chap_id)
        VALUES (NOW(), id_history_rax, e_cur, e_dur, e_name, NOW(), e_chap)
        RETURNING id INTO id_chap;
    ELSE
        DELETE FROM chaps
        USING history h
        JOIN users u ON h.user_id = u.id
        WHERE chaps.history_id = h.id AND h.season = season_id AND chaps.chap_id = e_chap AND u.uuid = user_uid
        AND NOT chaps.id = id_chap;

        UPDATE chaps
        SET cur = e_cur, dur = e_dur, updated_at = NOW()
        WHERE id = id_chap;
    END IF;

    IF latest_history is NULL then
        UPDATE history
        set v_chap = id_chap
        where id = id_history_rax;
    else
        UPDATE history
        SET v_chap = id_chap
        WHERE id = latest_history.id;
    end if;
END;
$function$
;

grant delete on table "public"."notify" to "anon";

grant insert on table "public"."notify" to "anon";

grant references on table "public"."notify" to "anon";

grant select on table "public"."notify" to "anon";

grant trigger on table "public"."notify" to "anon";

grant truncate on table "public"."notify" to "anon";

grant update on table "public"."notify" to "anon";

grant delete on table "public"."notify" to "authenticated";

grant insert on table "public"."notify" to "authenticated";

grant references on table "public"."notify" to "authenticated";

grant select on table "public"."notify" to "authenticated";

grant trigger on table "public"."notify" to "authenticated";

grant truncate on table "public"."notify" to "authenticated";

grant update on table "public"."notify" to "authenticated";

grant delete on table "public"."notify" to "service_role";

grant insert on table "public"."notify" to "service_role";

grant references on table "public"."notify" to "service_role";

grant select on table "public"."notify" to "service_role";

grant trigger on table "public"."notify" to "service_role";

grant truncate on table "public"."notify" to "service_role";

grant update on table "public"."notify" to "service_role";

grant delete on table "public"."notify_chap" to "anon";

grant insert on table "public"."notify_chap" to "anon";

grant references on table "public"."notify_chap" to "anon";

grant select on table "public"."notify_chap" to "anon";

grant trigger on table "public"."notify_chap" to "anon";

grant truncate on table "public"."notify_chap" to "anon";

grant update on table "public"."notify_chap" to "anon";

grant delete on table "public"."notify_chap" to "authenticated";

grant insert on table "public"."notify_chap" to "authenticated";

grant references on table "public"."notify_chap" to "authenticated";

grant select on table "public"."notify_chap" to "authenticated";

grant trigger on table "public"."notify_chap" to "authenticated";

grant truncate on table "public"."notify_chap" to "authenticated";

grant update on table "public"."notify_chap" to "authenticated";

grant delete on table "public"."notify_chap" to "service_role";

grant insert on table "public"."notify_chap" to "service_role";

grant references on table "public"."notify_chap" to "service_role";

grant select on table "public"."notify_chap" to "service_role";

grant trigger on table "public"."notify_chap" to "service_role";

grant truncate on table "public"."notify_chap" to "service_role";

grant update on table "public"."notify_chap" to "service_role";


